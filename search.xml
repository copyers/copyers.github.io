<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL相关基础与SQL索引优化分析</title>
    <url>/blog/2020/02/27/MySQL%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E4%B8%8ESQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<img src="https://img-blog.csdnimg.cn/20200227105100741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="" style="width:100%" />
<a id="more"></a>

<h2 id="一、MySQL基本知识"><a href="#一、MySQL基本知识" class="headerlink" title="一、MySQL基本知识"></a>一、MySQL基本知识</h2><h3 id="1-MySQL简介"><a href="#1-MySQL简介" class="headerlink" title="1. MySQL简介"></a>1. MySQL简介</h3><h4 id="1-1-什么是MySQL"><a href="#1-1-什么是MySQL" class="headerlink" title="1.1 什么是MySQL"></a>1.1 什么是MySQL</h4><p>​    MySQL是一个开源的关系型数据库，由MySQL AB公司开发，目前已被Oracle收购。其遵循GPL协议，用户可根据需求定制化开发资金的MySQL。MySQL可移植性高，支持多种语言，例如：Java、PHP、C++、Python、Perl、Eiffel、Rubby等。其使用标准的SQL数据语言形式，可通过如下数据语言进行使用：</p>
<ul>
<li><p>DQL：数据查询语言，select、from、where；</p>
</li>
<li><p>DML：数据操作语言，insert、delete、update；</p>
</li>
<li><p>DDL：数据定义语言，create、alter、drop、truncate；</p>
</li>
<li><p>DCL：数据控制语言，grant、rollback、commit</p>
<p>MySQL常用的SQL说明：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">SQL</th>
<th align="center">描述</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">show databases</td>
<td align="center">列出所有数据库</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">create database test01</td>
<td align="center">创建数据库test01</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">create database test01 character set utf8</td>
<td align="center">创建数据库，并设置字符集为utf-8</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">show create database test01</td>
<td align="center">查看数据库字符集</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">show variables like ’%char%‘</td>
<td align="center">查询参数</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">set [字符集属性]=utf8</td>
<td align="center">设置字符集属性为utf8</td>
<td align="center">仅临时更改，如需彻底修改需改配置文件</td>
</tr>
<tr>
<td align="center">alter database test01 character set ‘utf8’</td>
<td align="center">修改数据库字符集</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">alter table table01 convert to character set ’utf8‘</td>
<td align="center">修改数据表字符集</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大支持4GB，64位系统表文件最大支持8TB。在200万条记录下不加索引性能依旧较好。</p>
<p>注意：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">字符集需要安装之后立即修改，如果插入数据之后再进行修改则之前数据库、表格及数据依然为原编码格式！</span><br></pre></td></tr></table></figure>



<h3 id="2-安装MySQL"><a href="#2-安装MySQL" class="headerlink" title="2. 安装MySQL"></a>2. 安装MySQL</h3><h4 id="2-1-Windows安装"><a href="#2-1-Windows安装" class="headerlink" title="2.1 Windows安装"></a>2.1 Windows安装</h4><p>​    以5.7.28为例：参考博文<a href="https://blog.csdn.net/YueYingGuang/article/details/103410868" target="_blank" rel="noopener" title="MySQL 5.7.28安装最稳教程">MySQL 5.7.28安装最稳教程</a></p>
<h4 id="2-2-Linux安装"><a href="#2-2-Linux安装" class="headerlink" title="2.2 Linux安装"></a>2.2 Linux安装</h4><h5 id="2-2-1-docker安装"><a href="#2-2-1-docker安装" class="headerlink" title="2.2.1 docker安装"></a>2.2.1 docker安装</h5><p><a href="https://blog.csdn.net/YueYingGuang/article/details/103577110" target="_blank" rel="noopener">    CentOS 7 使用docker安装mysql</a></p>
<h5 id="2-2-2-yum-安装"><a href="#2-2-2-yum-安装" class="headerlink" title="2.2.2 yum 安装"></a>2.2.2 yum 安装</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mysql</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-rpm安装"><a href="#2-2-3-rpm安装" class="headerlink" title="2.2.3 rpm安装"></a>2.2.3 rpm安装</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep mysql</span><br><span class="line">rpm -ivh MySQL-client-xxx.linu.xxx.rpm</span><br><span class="line">rpm -ivh MySQL-server-xxx.linu.xxx.rpm</span><br></pre></td></tr></table></figure>

<h4 id="2-3-Linux下常用命令"><a href="#2-3-Linux下常用命令" class="headerlink" title="2.3 Linux下常用命令"></a>2.3 Linux下常用命令</h4><p> tips：</p>
<ul>
<li>查看MySQL所属用户：cat /etc/passwd/|grep mysql</li>
<li>查看MySQL所属组：cat /etc/group/|grep mysql</li>
<li>查看MySQL当前服务状态：service mysql status</li>
<li>启动关闭MySQL： service mysql start、service mysql stop、service mysql restart</li>
<li>设置MySQL开机启动：chkconfig mysql on、chkconfig –list|grep mysql、cat /etc/inittab或者netsysv图形化操作</li>
<li>设置MySQL用户名密码：mysqladmin -u root -p 123456</li>
<li>进程查看：ps -ef|grep mysql </li>
<li>设置大小写不敏感：show variables like ’%lower_case_table_names%‘，修改my.cnf下lower_case_table_names=1，即大小写不敏感。</li>
</ul>
<h4 id="2-4-sql-mode"><a href="#2-4-sql-mode" class="headerlink" title="2.4 sql_mode"></a>2.4 sql_mode</h4><p>​    sql_mode定义了对MySQL中的语法校验规则，其默认值是空值，这种情况下是可以进行一些非法操作的，生产环境下必须将该值设置为严格模式，以下为sql_mode常用的值。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ONLY_FULL_GROUP_BY</td>
<td align="center">若select未选中group by的字段，则SQL不合法</td>
</tr>
<tr>
<td align="center">NO_AUTO_VALUE_ON_ZERO</td>
<td align="center">自增长列可插入0或者null</td>
</tr>
<tr>
<td align="center">STRICT_TRANS_TABLES</td>
<td align="center">若一个值不能插入到事务表中，则中断，对非事务表不做限制</td>
</tr>
<tr>
<td align="center">NO_ZERO_IN_DATE</td>
<td align="center">严格模式下不允许日期和月份为零</td>
</tr>
<tr>
<td align="center">NO_ZERO_DATE</td>
<td align="center">日期不允许插入零</td>
</tr>
<tr>
<td align="center">ERROR_FOR_DIVISION_BY_ZERO</td>
<td align="center">insert或update中，若数据被零除，则报错，如果未给出该模式，则返回null</td>
</tr>
<tr>
<td align="center">NO_AUTO_CREATE_USER</td>
<td align="center">禁止grant创建密码为空的用户</td>
</tr>
<tr>
<td align="center">NO_ENGINE_SUBSTITUTION</td>
<td align="center">存储引擎被禁用则报错，若未设置则使用默认的存储引擎代替</td>
</tr>
</tbody></table>
<h5 id="2-4-1-查看和修改sql-mode"><a href="#2-4-1-查看和修改sql-mode" class="headerlink" title="2.4.1 查看和修改sql_mode"></a>2.4.1 查看和修改sql_mode</h5><p>查看：select @@sql_mode</p>
<p>修改：set @@sql_mode=’’;</p>
<h4 id="2-5-用户管理"><a href="#2-5-用户管理" class="headerlink" title="2.5 用户管理"></a>2.5 用户管理</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">create user z3 identified by ’123456‘</td>
<td align="center">创建名称为z3，密码为12346的用户</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">select host,user,password,select_priv,insert_priv,drop_priv from mysql.user</td>
<td align="center">查看用户和权限信息</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">set password = password(‘123456’)</td>
<td align="center">修改当前用户密码</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">update mysql.user set password=password(‘123456’) where user = ‘z3’</td>
<td align="center">修改其他用户密码</td>
<td align="center">通过user表的修改需要flush privileges才能生效</td>
</tr>
<tr>
<td align="center">update mysql.user set user = ‘li4’ where user =’z3’</td>
<td align="center">修改用户名</td>
<td align="center">通过user表的修改需要flush privileges才能生效</td>
</tr>
<tr>
<td align="center">drop user li4</td>
<td align="center">删除用户</td>
<td align="center">不要通过user表删除，系统会有残留</td>
</tr>
</tbody></table>
<p>host:表示连接类型</p>
<ul>
<li>%表示所有远程通过TCP连接</li>
<li>IP地址</li>
<li>机器名</li>
<li>::1 ipv6本机地址</li>
<li>localhost</li>
</ul>
<h4 id="2-6-权限管理"><a href="#2-6-权限管理" class="headerlink" title="2.6 权限管理"></a>2.6 权限管理</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">grant select,insert,delete,drop on mydb.* to z3@localhost</td>
<td align="center">给本地的z3用户的mydb数据库所有表授予增删改查权限</td>
</tr>
<tr>
<td align="center">grant all privileges on *.* to z3@’%’ identified by ‘123’</td>
<td align="center">授予通过网络登录的z3用户对所有库的权限，密码为123</td>
</tr>
<tr>
<td align="center">show grants</td>
<td align="center">查看权限</td>
</tr>
<tr>
<td align="center">revoke all privileges on mysql.* from z3@localhost</td>
<td align="center">收回z3全库全表所有权限</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、SQL优化"><a href="#二、SQL优化" class="headerlink" title="二、SQL优化"></a>二、SQL优化</h2><p>一般使用SQL操作数据库时，当遇到SQL执行时间太长怎么办呢？一般我们都是从下面四个方面进行查摆问题一一优化：</p>
<ul>
<li>查询语句过于粗糙</li>
<li>索引失效，明明增加了单值索引或者复合索引，但是explain查看执行计划却发现依旧是全表扫描</li>
<li>系统设计问题导致join关联查询太多</li>
<li>硬件方面需要优化，各缓冲参数设置过小（比如order by所使用的sort_buffer_size）</li>
</ul>
<p>在优化开始之前，我们需要了解MySQL的逻辑架构是怎样的，也就是MySQL是如何处理我们的SQL语句的呢？</p>
<hr>
<h3 id="1-MySQL架构分析"><a href="#1-MySQL架构分析" class="headerlink" title="1. MySQL架构分析"></a>1. MySQL架构分析</h3><img src="https://img-blog.csdnimg.cn/20200227105039257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70,color_FFFFFF,t_70" alt="" style="width:100%" />



<p>上图为MySQL逻辑架构图，其主要分为连接层、服务层、引擎层及存储层。</p>
<ul>
<li><p>连接层，MySQL最上层，它是一些客户端和连接服务，包含本地socket通信和基于客户端连接的类似tcp/ip通信，主要完成连接处理、授权认证及相关安全方案，该层引入了线程池的概念为安全认证客户端提供线程，<strong>例如驱动连接</strong>。</p>
</li>
<li><p>服务层：</p>
<table>
<thead>
<tr>
<th align="center">Management Services &amp; Utilities</th>
<th>系统管理和控制工具</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SQL Interface</td>
<td>SQL接口：接收SQL返回查询结果</td>
</tr>
<tr>
<td align="center">Parser</td>
<td>解析器：验证和解析SQL语句</td>
</tr>
<tr>
<td align="center">Optimizer</td>
<td>查询优化器：MySQL对SQL会根据优化器结果进行优化</td>
</tr>
<tr>
<td align="center">Cache&amp;Buffer</td>
<td>查询缓存：提高查询效率</td>
</tr>
</tbody></table>
</li>
<li><p>引擎层</p>
<p>可插拔式引擎的选择，负责MySQL中数据的存储和查询，目前MySQL最常用的两种数据库存储引擎为InnoDB与MyISAM，下表为二者的区别。</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">InnoDB</th>
<th align="center">MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否支持事务</td>
<td align="center">支持</td>
<td align="center">不支持事务</td>
</tr>
<tr>
<td align="center">是否支持外键</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">索引类型</td>
<td align="center">聚簇索引</td>
<td align="center">非聚簇索引</td>
</tr>
<tr>
<td align="center">是否保存表的行数</td>
<td align="center">否</td>
<td align="center">是（通过变量保存，避免select count(*) 时进行全表扫描）</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">5.7以后支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">是否可压缩后查询</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">锁的粒度</td>
<td align="center">行锁</td>
<td align="center">表锁</td>
</tr>
<tr>
<td align="center">主键是否必须</td>
<td align="center">是（聚簇索引特性）</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">存储文件</td>
<td align="center">frm（表结构），ibd（数据文件）</td>
<td align="center">frm（表结构），myd（数据文件），myi（索引文件）</td>
</tr>
</tbody></table>
<img src="https://img-blog.csdnimg.cn/20200227105100741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="" style="width:100%" />

<blockquote>
<p>tips: </p>
<p>1、聚簇索引与非聚簇索引</p>
<p>聚簇索引：数据与索引是在同一B+Tree上的，非叶子节点存放的是索引（数据的指针），叶子节点存放的是数据，该索引类型必须有主键，数据可通过主键进行查询，之后建立的索引为辅助索引，辅助索引需要两次查询，先查询到主键，然后通过主键查询数据，所以主键最好设置为自增，否则主键过大会带来额外开销；</p>
<p>非聚簇索引：B+Tree的非叶子节点和叶子节点存放的都是数据的引用地址，数据文件与索引文件是分开保存的。</p>
<p>2、<strong>InnoDB的行锁是实现在索引上的，而不是锁在物理上，如果索引失效则行锁会退化为表锁。</strong></p>
</blockquote>
</li>
<li><p>存储层<br>数据库文件的数据存储在文件系统上的方式，并通过该存储方式与存储引擎交互。</p>
</li>
</ul>
<hr>
<h3 id="2-SQL执行分析"><a href="#2-SQL执行分析" class="headerlink" title="2. SQL执行分析"></a>2. SQL执行分析</h3><h4 id="2-1-SQL查询流程"><a href="#2-1-SQL查询流程" class="headerlink" title="2.1 SQL查询流程"></a>2.1 SQL查询流程</h4><p>通过对MySQL逻辑结构的分析，我们可以知道SQL查询的流程大致为：</p>
<ol>
<li>MySQL客户端通过协议与MySQL服务器建立连接，发送查询语句；</li>
<li>MySQL检查查询缓存，缓存如果命中则直接返回，未命中则将语句交由解析器处理；</li>
<li>解析器通过关键字对SQL语句预处理，生成解析树并验证SQL语法，若语法通过则交由优化器；</li>
<li>优化器将SQL转化成执行计划并选择最好的执行；</li>
<li>优化器将最终的查询结果返回。</li>
</ol>
<p>SQL手写为：<img src="https://img-blog.csdnimg.cn/20200227105125196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="" style="width:100%" /></p>
<p>优化器优化之后的顺序：</p>
<img src="https://img-blog.csdnimg.cn/20200227105138922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="" style="width:100%" />



<blockquote>
<p>tips: </p>
<ul>
<li>show engines可查看所有数据库引擎</li>
<li>show variables like ‘%storage_engine%’ 可查看当前默认数据库引擎</li>
</ul>
</blockquote>
<hr>
<h4 id="2-2-show-profile"><a href="#2-2-show-profile" class="headerlink" title="2.2 show profile"></a>2.2 show profile</h4><h5 id="2-2-1-SQL执行周期"><a href="#2-2-1-SQL执行周期" class="headerlink" title="2.2.1 SQL执行周期"></a>2.2.1 SQL执行周期</h5><p>通过show profile可以查看SQL的详细执行周期，可以作为优化SQL最强有力的工具。</p>
<ol>
<li><p>通过show variables like ‘%profiling%’查看是否开启该功能；</p>
<img src="https://img-blog.csdnimg.cn/20200227105208553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="" style="width:100%" />
</li>
<li><p>set profiling = 1；开启show profile；</p>
</li>
<li><p>show profile cpu,block io for query Query_id；查询SQL详细执行信息。</p>
<img src="https://img-blog.csdnimg.cn/20200227105226954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="" style="width:100%" />

</li>
</ol>
<p>show profiles可以提供SQL执行的详细信息，但是实际中我们更多使用explain对SQL进行解释优化，查看SQL是否使用索引等等，下文更多是针对explain的使用进行介绍。</p>
<hr>
<h3 id="3-SQL索引优化"><a href="#3-SQL索引优化" class="headerlink" title="3. SQL索引优化"></a>3. SQL索引优化</h3><hr>
<p>如何提高SQL执行速度？许多人第一反应就是增加索引，什么是索引呢？如何增加索引且增加的索引不会因为SQL问题导致失效呢？</p>
<p>我们知道MySQL底层使用B+树实现，索引作为数据的另一种表现形式同样也会耗费存储空间的。</p>
<p>如果单纯的为了提升某个字段的查询效率而在全表字段上都增加索引，那么无疑给存储空间带来了巨大负担。而且索引增加之后虽然给查询带来了便利，但是在增加和删除方面，为了维护索引而带来的工作量也是极为繁重的，这说明了不经研究而随意建立索引的方法是不可取的。</p>
<hr>
<h4 id="3-1-索引简介"><a href="#3-1-索引简介" class="headerlink" title="3.1 索引简介"></a>3.1 索引简介</h4><h5 id="3-1-什么是索引？"><a href="#3-1-什么是索引？" class="headerlink" title="3.1 什么是索引？"></a>3.1 什么是索引？</h5><p>​        索引是帮助MySQL高效获取数据的数据结构，所以索引可以简单理解为排好序的快速查找数据结构。</p>
<h5 id="3-2-索引的优缺点"><a href="#3-2-索引的优缺点" class="headerlink" title="3.2 索引的优缺点"></a>3.2 索引的优缺点</h5><p><strong>优点：</strong></p>
<ul>
<li>提高数据检索的效率，降低数据库的IO成本；</li>
<li>索引是一种排好序的数据结构，通过索引进行排序可以降低数据的排序成本。</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>降低更新表的速度，加了索引的字段在insert、update、delete时会带来额外的开销；</li>
<li>占用多余的空间。</li>
</ul>
<hr>
<h4 id="3-2-适合创建索引的情况"><a href="#3-2-适合创建索引的情况" class="headerlink" title="3.2 适合创建索引的情况"></a>3.2 适合创建索引的情况</h4><ul>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段需要建立索引</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>组合索引性价比优于单值索引</li>
<li>查询中排序的字段</li>
<li>查询中统计或者分组的字段</li>
</ul>
<hr>
<h4 id="3-3-不适合创建索引的情况"><a href="#3-3-不适合创建索引的情况" class="headerlink" title="3.3 不适合创建索引的情况"></a>3.3 不适合创建索引的情况</h4><ul>
<li>表记录太少</li>
<li>经常增删改的表或者字段</li>
<li>where条件里用不到的字段不创建索引</li>
<li>字段中重复内容较多，过滤性不好的不适合建立索引</li>
</ul>
<hr>
<h4 id="3-4-explain性能参数分析"><a href="#3-4-explain性能参数分析" class="headerlink" title="3.4 explain性能参数分析"></a>3.4 explain性能参数分析</h4><p>在日常工作中，使用最为频繁的就是通过explain+SQL模拟优化器执行SQL语句，从而知道MySQL是如何处理SQL语句的，并根据情况分析SQL的性能瓶颈以优化SQL。</p>
<p>那么，通过explain我们可以获得什么信息呢？</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<h5 id="3-4-1-explain参数"><a href="#3-4-1-explain参数" class="headerlink" title="3.4.1 explain参数"></a>3.4.1 explain参数</h5><p>我们通过explain+SQL的方式可以获得如下所示的列表：</p>
<img src="https://img-blog.csdnimg.cn/20200227105249657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="" style="width:100%" />

<p>可以看出主要参数即：id，select_type,table,partitions,<strong>type</strong>,<strong>possible_keys,key</strong>,key_len,ref,rows,filtered,<strong>Extra</strong>。</p>
<p>以下针对第一行参数进行详细分析：</p>
<ul>
<li><p><strong>id</strong>：select查询的序列号，包含一组数字，表示查询中select子句或操作表的顺序，主要分以下三种情况：</p>
<ul>
<li>id相同，执行顺序由上至下；</li>
<li>id不同，如果是子查询，id的序号会较大，此时优先级越高，也就越先被执行；</li>
<li>id相同不同，同时存在时先根据不同定优先级，再由上至下进行执行；</li>
</ul>
</li>
<li><p>select_type：查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询，具体参数如下：</p>
<ul>
<li>SIMPLE：简单的select查询，不包含子查询或者UNION；</li>
<li>PRIMARY：查询中若包含其他子查询，则最外层会被标记为PRIMARY；</li>
<li>SUBQUERY：select或者where中包含了子查询；</li>
<li>DERIVED：From中包含的子查询，临时表；</li>
<li>UNION：第二个select出现在UNION之后则会被标记为UNION；</li>
<li>UNION RESULT：从UNION中获取结果的select；</li>
</ul>
</li>
<li><p>table：显示改行的数据来源于哪张表</p>
</li>
<li><p>partitions：是否分区</p>
</li>
<li><p><strong>type：</strong>优化器定义的访问类型，从最好到最差依次是<strong>scerria</strong>（system&gt;const&gt;ref_eq&gt;ref&gt;range&gt;index&gt;all），具体含义如下：</p>
<ul>
<li>system：表中只有一行记录，相当于const类型的特例，平时不会出现；</li>
<li>const：通过索引一次就找到了，const用于比较primary key或者unique索引；</li>
<li>eq_ref：唯一性索引，对于每个索引键，表中只有一条记录与之匹配，<strong>简单地说是const是直接按主键或唯一键读取，eq_ref用于联表查询的情况，按联表的主键或唯一键联合查询</strong>；</li>
<li>ref：非唯一性索引，返回匹配某个值的所有行（一值找多行）;</li>
<li>range：索引给定范围的行，例如where中的between、in，这种范围索引较全表扫描要好，因为范围决定了不用全表扫描；</li>
<li>index：full index，全表索引扫描，效果与all的区别就是index扫描的是全表的索引，而all扫描的是数据；</li>
<li>all：全表数据扫描，匹配到之后返回结果。</li>
</ul>
<blockquote>
<p>一般来说，保证查询达到range或者ref效果为佳。</p>
</blockquote>
</li>
<li><p><strong>possible_keys：</strong>显示可能应用在这张表中的索引，一个或多个。查询所涉及字段若存在索引，则索引将被列出，但不一定被使用</p>
</li>
<li><p><strong>key：</strong>查询中实际使用的索引，如果没有则为null，查询中如果使用了覆盖索引，则索引和查询的字段一一吻合</p>
</li>
<li><p>key_len：表示索引使用到的字节数，可通过该值计算查询中使用的索引长度。在不损失精度的情况下，该值越小越好。该值为索引最大可能长度，并非实际使用长度。</p>
</li>
<li><p>ref：显示索引哪一列被使用了，哪些列或者常数被用于索引进行查询（最好是常数）。也就是说key 列是实际使用的 index ， 但 index 可能建立在数据表的若干列上。ref 列列出具体哪些列或常数被使用了。</p>
</li>
<li><p>rows：根据表统计信息及索引使用情况大致估算除所需要读取的行数</p>
</li>
<li><p>filtered：返回结果的行占需要读到的行(rows列的值)的百分比，因为对于join操作，前一个表的结果集大小直接影响了循环的次数</p>
</li>
<li><p><strong>Extra：包含不适合在其他列中显示但十分重要的额外信息</strong>，其主要会有以下几个常数：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Using filesort</td>
<td align="center">MySQL会对数据使用外部的文件索引排序，而不是按照表内索引顺序读取，文件的建立删除会耗费大量资源，出现该项一定要优化</td>
</tr>
<tr>
<td align="center">Using temporary</td>
<td align="center">使用临时表保存中间结果，常见于order by、group by，临时表的创建与删除会耗费大量资源，出现该项一定要优化</td>
</tr>
<tr>
<td align="center">Using index</td>
<td align="center">相应的select中使用了覆盖索引，避免访问冗余数据，效果不错，同时出现Using where则表明索引被用来执行索引键的查找，若没有出现Using where 则表明索引用于读取数据而非执行查找</td>
</tr>
<tr>
<td align="center">Using where</td>
<td align="center">表明使用了where过滤</td>
</tr>
<tr>
<td align="center">Using join buffer</td>
<td align="center">使用了连接缓存，可在my.cnf中增加缓存大小</td>
</tr>
<tr>
<td align="center">impossible where</td>
<td align="center">where的值总是false，不能获取任何值</td>
</tr>
<tr>
<td align="center">select tables optimized away</td>
<td align="center">在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</td>
</tr>
<tr>
<td align="center">distinct</td>
<td align="center">优化distinct，找到第一匹配值即停止</td>
</tr>
</tbody></table>
</li>
</ul>
<p>以上就是对explain参数的分析，通过对这些参数的学习，将使得我们以后在SQL优化方面无论遇到什么问题都能对症下药，迎刃而解。</p>
<hr>
<h4 id="3-5-索引失效情况分析"><a href="#3-5-索引失效情况分析" class="headerlink" title="3.5 索引失效情况分析"></a>3.5 索引失效情况分析</h4><p>有时候我们明明在字段上建立了索引，但是explain之后发现优化器并没有使用到索引，那什么情况下会导致索引失效？写SQL语句时应该注意些什么才能避免索引失效呢？</p>
<h5 id="3-5-1-索引失效"><a href="#3-5-1-索引失效" class="headerlink" title="3.5.1 索引失效"></a>3.5.1 索引失效</h5><p>以下是常见导致索引失效的几种情况：</p>
<ol>
<li>最左前缀法则：建立的复合索引在使用时没有遵循最左前缀法则，例如索引使用了（a,b,c）三个字段，但是使用的时候a没有使用到，索引失效；</li>
<li>在索引字段上进行计算，函数处理，类型转换等二次操作；</li>
<li>范围条件右边的列索引失效，即范围之后全失效，例如索引为（id,age,name）,使用时如果出现where id=xx and age&gt;10 and name=xx，则age之后索引失效；</li>
<li>尽量使用覆盖索引，避免select *，即复合索引的字段与查询字段一一吻合；</li>
<li>!=或&lt;&gt;会导致索引失效；</li>
<li>is null，is not null会导致索引失效；</li>
<li>使用like模糊查询时如果%出现在最左边则索引失效，解决办法就是使用覆盖索引；</li>
<li>字符串不加单引号；</li>
<li>多次使用or会导致索引失效。</li>
</ol>
<p>以上就是会造成MySQL索引失效的一些情况，为了避免这些情况的出现而造成索引失效，建议：</p>
<ul>
<li>对于单值索引，尽量选择针对查询过滤性更好的字段来建立索引，例如性别只有男、女、未知的三类就没有必要建立索引；</li>
<li>复合索引过滤性最好的字段要放在最前面；</li>
<li>复合索引尽可能包含查询字段中where子句中更多的字段；</li>
<li>通过分析统计信息和调整SQL查询的写法来选择建立合适的索引。</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>索引优化</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法——Java排序算法之冒泡排序及优化</title>
    <url>/blog/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>通过增加了判断数组在某一轮下是否已经有序的标识来提高冒泡排序的运算效率</p>
<a id="more"></a>

<hr>
<blockquote>
<p>排序算法是我们在数据结构与算法中必学掌握的重点，下面着重以代码的方式复习一下冒泡排序。</p>
</blockquote>
<ul>
<li>普通的冒泡排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通的冒泡排序：比较相邻元素之间的大小，如果发现当前顺序与所期望的顺序不一致则进行交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收数组长度</span></span><br><span class="line">        <span class="keyword">int</span> length = arrs.length;</span><br><span class="line">        <span class="comment">//定义一个临时变量用于交换</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for循环遍历数组元素，外层为交换的轮数，内循环为每轮比较的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//判断当前数如果大于其后面的数时进行交换（因为我们的顺序是从小到大，只有当前数小于等于后一个数时不用交换）</span></span><br><span class="line">                <span class="keyword">if</span> (arrs[j] &gt; arrs[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">//通过临时变量来进行交换，如果不使用临时变量直接赋值会造成覆盖</span></span><br><span class="line">                    temp = arrs[j];</span><br><span class="line">                    arrs[j] = arrs[j + <span class="number">1</span>];</span><br><span class="line">                    arrs[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是此时，该算法的平均时间复杂度为O(n^2)，当数据量较大的时候需要大量的时间，为此，出现了对上面算法的改进。</p>
<ul>
<li>改进一</li>
</ul>
<blockquote>
<p>通过增加了判断数组在某一轮下是否已经有序的标识来提高冒泡排序的运算效率。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">improved1BubbleSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收数组长度</span></span><br><span class="line">        <span class="keyword">int</span> length = arrs.length;</span><br><span class="line">        <span class="comment">//定义一个临时变量用于交换</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">//判断是否进行了数据交换的标识，0为发生了数据交换，1表示没有发生交换（即数据当前顺序符合期望顺序）</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for循环遍历数组元素，外层为交换的轮数，内循环为每轮比较的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">//判断当前数如果大于其后面的数时进行交换（因为我们的顺序是从小到大，只有当前数小于等于后一个数时不用交换）</span></span><br><span class="line">                <span class="keyword">if</span> (arrs[j] &gt; arrs[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">//通过临时变量来进行交换，如果不使用临时变量直接赋值会造成覆盖</span></span><br><span class="line">                    temp = arrs[j];</span><br><span class="line">                    arrs[j] = arrs[j + <span class="number">1</span>];</span><br><span class="line">                    arrs[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    <span class="comment">//上面表示发生了数据交换，则把flag置为1</span></span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前轮完成之后，立即判断该轮是否进行过交换，如果flag为0则说明没有交换，数组已经有序直接跳出for循环，反之则继续进行冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>改进二</li>
</ul>
<blockquote>
<p>记录上一轮最后比较位置作为下一轮比较的末位置缩短比较次数，因为我选定的顺序是从小到大，所以后面的顺序先确定。如果选定的顺序是从大到小，则该记录位置应该作为下一次的起始位置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在每轮比较中增加一个判断标识，如果当前一轮中一次数据交换都没有发生，则说明数据已经有序，后面的轮数也不用再进行，直接break跳出循环</span></span><br><span class="line"><span class="comment">//当产生了数据交换则记录当前交换的位置作为下一轮起始位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">improved2BubbleSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收数组长度</span></span><br><span class="line">        <span class="keyword">int</span> length = arrs.length;</span><br><span class="line">        <span class="comment">//定义一个临时变量用于交换</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">//判断是否进行了数据交换的标识，0为发生了数据交换，1表示没有发生交换（即数据当前顺序符合期望顺序）</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pos用于记录最后一次交换的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//innerlength用于记录内层比较的位置</span></span><br><span class="line">        <span class="keyword">int</span> innerlength = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for循环遍历数组元素，外层为交换的轮数，内循环为每轮比较的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; innerlength; j++) &#123;</span><br><span class="line">                <span class="comment">//判断当前数如果大于其后面的数时进行交换（因为我们的顺序是从小到大，只有当前数小于等于后一个数时不用交换）</span></span><br><span class="line">                <span class="keyword">if</span> (arrs[j] &gt; arrs[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">//通过临时变量来进行交换，如果不使用临时变量直接赋值会造成覆盖</span></span><br><span class="line">                    temp = arrs[j];</span><br><span class="line">                    arrs[j] = arrs[j + <span class="number">1</span>];</span><br><span class="line">                    arrs[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    <span class="comment">//上面表示发生了数据交换，则把flag置为1</span></span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//记录当前轮最后交换的位置</span></span><br><span class="line">                    <span class="comment">// 因为这里我选择的顺序是从小到大，所以是后面的顺序是最先确定，下一轮判断到该位置即可</span></span><br><span class="line">                    <span class="comment">// 如果选择的顺序是从大到小，则前面的顺序是最先确定，下一轮要从该位置开始</span></span><br><span class="line">                    pos = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下一轮循环至该位置即可</span></span><br><span class="line">            innerlength = pos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前轮完成之后，立即判断该轮是否进行过交换，如果flag为0则说明没有交换，数组已经有序直接跳出for循环，反之则继续进行冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>改进三</li>
</ul>
<blockquote>
<p>在上一算法的基础上，新增了在当前轮数中增加同时寻找最小值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在每轮比较中增加一个判断标识，如果当前一轮中一次数据交换都没有发生，则说明数据已经有序，后面的轮数也不用再进行，直接break跳出循环</span></span><br><span class="line">    <span class="comment">//当产生了数据交换则记录当前交换的位置作为下一轮起始位置，同时在每轮中增加寻找最小数的过程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">improved3BubbleSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收数组长度</span></span><br><span class="line">        <span class="keyword">int</span> length = arrs.length;</span><br><span class="line">        <span class="comment">//定义一个临时变量用于交换</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">//判断是否进行了数据交换的标识，0为发生了数据交换，1表示没有发生交换（即数据当前顺序符合期望顺序）</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pos用于记录最后一次交换的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//寻找最小值的下标</span></span><br><span class="line">        <span class="keyword">int</span> minindex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//innerlength用于记录内层比较的位置</span></span><br><span class="line">        <span class="keyword">int</span> innerlength = length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义一个临时变量用于交换最小数</span></span><br><span class="line">        <span class="keyword">int</span> tempmin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用于记录最小数交换的位置</span></span><br><span class="line">        <span class="keyword">int</span> minnext = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for循环遍历数组元素，外层为交换的轮数，内循环为每轮比较的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; innerlength; j++) &#123;</span><br><span class="line">                <span class="comment">//判断当前数如果大于其后面的数时进行交换（因为我们的顺序是从小到大，只有当前数小于等于后一个数时不用交换）</span></span><br><span class="line">                <span class="keyword">if</span> (arrs[j] &gt; arrs[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">//通过临时变量来进行交换，如果不使用临时变量直接赋值会造成覆盖</span></span><br><span class="line">                    temp = arrs[j];</span><br><span class="line">                    arrs[j] = arrs[j + <span class="number">1</span>];</span><br><span class="line">                    arrs[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    <span class="comment">//上面表示发生了数据交换，则把flag置为1</span></span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//记录当前轮最后交换的位置</span></span><br><span class="line">                    <span class="comment">// 因为这里我选择的顺序是从小到大，所以是后面的顺序是最先确定，所以下一轮判断到该位置即可</span></span><br><span class="line">                    <span class="comment">// 如果选择的顺序是从大到小，则前面的顺序是最先确定，下一轮要从该位置开始</span></span><br><span class="line">                    pos = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下一轮循环至该位置即可</span></span><br><span class="line">            innerlength = pos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前轮完成之后，立即判断该轮是否进行过交换，如果flag为0则说明没有交换，数组已经有序直接跳出for循环，反之则继续进行冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反向寻找最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = innerlength; j &gt; minindex; j--) &#123;</span><br><span class="line">                tempmin = arrs[j];</span><br><span class="line">                arrs[j] = arrs[j - <span class="number">1</span>];</span><br><span class="line">                arrs[j - <span class="number">1</span>] = tempmin;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//记录作为下一次的起始位置</span></span><br><span class="line">                minnext = j;</span><br><span class="line">            &#125;</span><br><span class="line">            minindex = minnext;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是不管怎么优化，因为涉及到两次遍历数组，冒泡排序的最好时间复杂度为O(n)，最坏时间复杂度依然为O(n^2)。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>排序</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB图像处理（一）——计算机图形学之图像形状识别</title>
    <url>/blog/2020/02/12/MATLAB%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%BD%A2%E7%8A%B6%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<img src="https://img-blog.csdnimg.cn/20190718133000508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="" style="width:100%" />
<a id="more"></a>

<h1>MATLAB图像处理（一）——计算机图形学之图像形状识别</h1>
由于遇到了很多次这个课题，这次做完之后结合手上的资料总结一下。

<h2 >基本步骤：</h2>
<h3 ><a href="#1" target="_self">1、读取彩色图像转化为二值图像；</a></h3>
<h3><a href="#2" target="_self">2、确定图像中的形状边界；</a></h3>
<h3 ><a href="#3" target="_self">3、确定所需形状的目标；</a></h3>
本文主要通过识别圆形目标来进行说明，原图如下所示，本例需要识别出下图中的圆形物体：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190718133000508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70)

<h2 id="1">1、读取彩色图像转化为二值图像</h2>
针对图像中可能有不同形状的目标物体，为了进行目标筛选，可以先通过形状判断，过滤掉我们不需要的物体，极大地提高图像识别的效率。

<p>1） 读取彩色图像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 1、读取图像并转化为二值图像</span><br><span class="line">RGB &#x3D; imread(&#39;ImageSeg.png&#39;);</span><br><span class="line">figure;imshow(RGB);title(&#39;原图像&#39;);</span><br></pre></td></tr></table></figure>
<p>2）将彩色图像转化为二值图像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 转化为灰度图像</span><br><span class="line">I &#x3D; rgb2gray(RGB);</span><br><span class="line">% 设置阈值</span><br><span class="line">threshold &#x3D; graythresh(I);</span><br><span class="line">% 转化为二值图像</span><br><span class="line">bw &#x3D; im2bw(I,threshold);</span><br></pre></td></tr></table></figure>
<p>注意：如果使用阈值公式进行转化，转化出的效果如果不符合预期的话需要手动调整阈值，上面代码的效果如下：<br><img src="https://img-blog.csdnimg.cn/20190718133707689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以我们根据图像像素的特性人为调整阈值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bw &#x3D; im2bw(I,0.69);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190718133845638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>调整后的二值图像如上图所示，可以看到物体形状非常清晰，但是明显看到背景有许多噪点，所以在这里为了去除这些噪点我们进行了人工去噪，去噪的代码如下，即简单的领域判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 通过领域判断手动去噪</span><br><span class="line">[m,n] &#x3D; size(bw);</span><br><span class="line">for i &#x3D; 2:m-1</span><br><span class="line">   for j &#x3D; 2:n-1</span><br><span class="line">       %同上下元素判断       </span><br><span class="line">       if(bw(i,j)~&#x3D;bw(i+1,j) &amp;&amp; bw(i,j)~&#x3D;bw(i-1,j))</span><br><span class="line">           bw(i,j) &#x3D; 1;</span><br><span class="line">       %同左右元素判断</span><br><span class="line">       elseif(bw(i,j)~&#x3D;bw(i,j+1) &amp;&amp; bw(i,j)~&#x3D;bw(i,j-1))</span><br><span class="line">           bw(i,j) &#x3D; 1;</span><br><span class="line">       %同斜边元素判断</span><br><span class="line">       elseif(bw(i,j)~&#x3D;bw(i+1,j+1) &amp;&amp; bw(i,j)~&#x3D;bw(i-1,j-1))</span><br><span class="line">           bw(i,j) &#x3D; 1;</span><br><span class="line">       %同斜边元素判断</span><br><span class="line">       elseif(bw(i,j)~&#x3D;bw(i-1,j+1) &amp;&amp; bw(i,j)~&#x3D;bw(i+1,j-1))</span><br><span class="line">           bw(i,j) &#x3D; 1;</span><br><span class="line">       end</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>去噪之后的二值图像为：<br><img src="https://img-blog.csdnimg.cn/20190718134319330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后对以上图像进行取反，以备下面使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i &#x3D; 1:m</span><br><span class="line">    for j &#x3D; 1:n</span><br><span class="line">        bw(i,j) &#x3D; ~bw(i,j);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>结果为<br><img src="https://img-blog.csdnimg.cn/20190718134548374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2">2、确定图像中的形状边界</h2>
首先去除小目标，由于本例图像中不存在小目标，所以可省略该步骤，其次进行孔洞填充并进行白色描边，最后通过bwboundaries函数确定图像边界。

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 去除小目标，因为本图没有小目标，所以可以不需要本条语句</span><br><span class="line">bw &#x3D; bwareaopen(bw,30);</span><br><span class="line">% 图形学结构元素构建，圆形</span><br><span class="line">se &#x3D; strel(&#39;disk&#39;,8);</span><br><span class="line">% 关操作</span><br><span class="line">bw &#x3D; imclose(bw,se);</span><br><span class="line">% 填充孔洞</span><br><span class="line">bw &#x3D; imfill(bw,&#39;holes&#39;);</span><br><span class="line">% 二值化图像显示</span><br><span class="line">figure(1);imshow(bw);title(&#39;二值图像&#39;);</span><br><span class="line">[B,L] &#x3D; bwboundaries(bw,&#39;noholes&#39;);</span><br><span class="line">figure(2);imshow(label2rgb(L,@jet,[.5 .5 .5]));</span><br><span class="line">hold on;</span><br><span class="line">for k &#x3D; 1:length(B)</span><br><span class="line">boundary &#x3D; B&#123;k&#125;;</span><br><span class="line">% 显示白色边界</span><br><span class="line">plot(boundary(:,2),boundary(:,1),&#39;w&#39;,&#39;LineWidth&#39;,2)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190718135018675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3">3、确定所需形状的目标</h2>
确定圆形目标，求取图形周长，圆心，面积，人为设置阈值进行过滤，在这里我设置阈值为0.85，即形状比对大于这个阈值的就是我们所需要的目标物体。

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hold on;</span><br><span class="line">% 确定圆形目标</span><br><span class="line">stats &#x3D; regionprops(L,&#39;Area&#39;,&#39;Centroid&#39;);</span><br><span class="line">% 设置求面积</span><br><span class="line">threshold &#x3D; 0.85;</span><br><span class="line">for k &#x3D; 1:length(B)</span><br><span class="line">    boundary &#x3D; B&#123;k&#125;;</span><br><span class="line">    delta_sq &#x3D; diff(boundary).^2;</span><br><span class="line">    % 求周长     </span><br><span class="line">    perimeter &#x3D; sum(sqrt(sum(delta_sq,2)));</span><br><span class="line">    % 求面积     </span><br><span class="line">    area &#x3D; stats(k).Area;</span><br><span class="line">    metric &#x3D; 4*pi*area&#x2F;perimeter^2;</span><br><span class="line">    metric_string &#x3D; sprintf(&#39;%2.2f&#39;,metric);</span><br><span class="line">    % 根据阈值匹配</span><br><span class="line">    if metric &gt; threshold  </span><br><span class="line">       centroid &#x3D; stats(k).Centroid;</span><br><span class="line">       plot(centroid(1),centroid(2),&#39;ko&#39;);</span><br><span class="line">       text(centroid(1)-2,centroid(2)-2, &#39;这是圆形&#39;,&#39;Color&#39;,...</span><br><span class="line">        &#39;k&#39;,&#39;FontSize&#39;,14,&#39;FontWeight&#39;,&#39;bold&#39;);</span><br><span class="line">    end</span><br><span class="line">       text(boundary(1,2)-10,boundary(1,1)-12, metric_string,&#39;Color&#39;,...</span><br><span class="line">        &#39;k&#39;,&#39;FontSize&#39;,14,&#39;FontWeight&#39;,&#39;bold&#39;);</span><br><span class="line">end</span><br><span class="line">title(&#39;图像形状识别&#39;)</span><br></pre></td></tr></table></figure>
<p>最后识别的效果图为：<br><img src="https://img-blog.csdnimg.cn/20190718135431953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>源代码及所使用的文件链接：<a href="https://download.csdn.net/download/yueyingguang/11381702" target="_blank" rel="noopener">https://download.csdn.net/download/yueyingguang/11381702</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>图像处理</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试——关于synchronized与ReentrantLock的详细区别</title>
    <url>/blog/2020/02/12/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8Esynchronized%E4%B8%8EReentrantLock%E7%9A%84%E8%AF%A6%E7%BB%86%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<img src="https://img-blog.csdnimg.cn/2020010912445595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="" style="width:100%" />

<a id="more"></a>

<h2 id="synchronized与ReentrantLock的区别"><a href="#synchronized与ReentrantLock的区别" class="headerlink" title="synchronized与ReentrantLock的区别"></a>synchronized与ReentrantLock的区别</h2><blockquote>
<p>工作与面试中经常会遇到Java常见的加锁方法，本文着重介绍一下synchronized与ReentrantLock的区别，总结一下目前在这方面学习到的知识。</p>
</blockquote>
<p>① <strong>底层实现</strong>上来说，synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor–对象来完成（monitorenter与monitorexit），对象只有在同步块或同步方法中才能调用wait/notify方法，ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的<strong>API层面</strong>的锁。</p>
<p>synchronzied的实现涉及到锁的升级，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁，ReentrantLock实现则是通过利用CAS（CompareAndSwap）自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">new</span> Object())&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>

<p>使用javap -c对如上代码进行反编译得到如下代码：<br><img src="https://img-blog.csdnimg.cn/2020010912445595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>② <strong>是否可手动释放：</strong></p>
<ul>
<li>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用；</li>
</ul>
<ul>
<li>ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try/finally语句块来完成，使用释放更加灵活。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>③ <strong>是否可中断</strong></p>
<ul>
<li><p>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成；</p>
</li>
<li><p>ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>④  <strong>是否公平锁</strong></p>
<ul>
<li><p>synchronized为非公平锁</p>
</li>
<li><p>ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>⑤ <strong>锁是否可绑定条件Condition</strong></p>
<ul>
<li><p>synchronized不能绑定；</p>
</li>
<li><p>ReentrantLock通过绑定Condition结合await()/singal()方法实现线程的精确唤醒，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。</p>
<p>  示例：用ReentrantLock绑定三个条件实现线程A打印一次1，线程B打印两次2，线程C打印三次3</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;<span class="comment">//A:1  B:2  C:3</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 do sth</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3 通知</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 do sth</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3 通知</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 do sth</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3 通知</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">                resource.print1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">                resource.print2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">                resource.print3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>输出结果为：</p>
<p>A    1<br>B    2<br>B    2<br>C    3<br>C    3<br>C    3<br>A    1<br>B    2<br>B    2<br>C    3<br>C    3<br>C    3</p>
<p>⑥ <strong>锁的对象</strong></p>
<ul>
<li>synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁/争抢锁；ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得/争抢。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>锁</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat Premium 12下看不到PostgreSQL下已创建的表</title>
    <url>/blog/2020/02/12/Navicat-Premium-%E4%B8%8B%E7%9C%8B%E4%B8%8D%E5%88%B0PostgreSQL%E4%B8%8B%E5%B7%B2%E5%88%9B%E5%BB%BA%E7%9A%84%E8%A1%A8/</url>
    <content><![CDATA[<p>通过Navicat Premium 12连接PostgreSQL之后发现找不到已存在的表，通过PostgreSQL自带的连接工具可以看到表是已经存在了的。</p>
<a id="more"></a>

<h2 id="Navicat-Premium-12下看不到PostgreSQL下已创建的表"><a href="#Navicat-Premium-12下看不到PostgreSQL下已创建的表" class="headerlink" title="Navicat Premium 12下看不到PostgreSQL下已创建的表"></a>Navicat Premium 12下看不到PostgreSQL下已创建的表</h2><blockquote>
<p>正文</p>
</blockquote>
<ul>
<li><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3></li>
</ul>
<blockquote>
<p>通过Navicat Premium 12连接PostgreSQL之后发现找不到已存在的表，通过PostgreSQL自带的连接工具可以看到表是已经存在了的。</p>
</blockquote>
<ul>
<li><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><blockquote>
<p>换最新版本Navicat Premium，这里使用Navicat Premium 15即可解决问题。</p>
</blockquote>
</li>
<li><h3 id="网盘下载地址（附注册机）"><a href="#网盘下载地址（附注册机）" class="headerlink" title="网盘下载地址（附注册机）"></a>网盘下载地址（附注册机）</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">百度网盘地址：   https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1_uPZwgL4EUC9P6r_MYs0nw</span><br><span class="line">提取码：        2h9f</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PostgreSQL,Navicat</category>
      </categories>
      <tags>
        <tag>Navicat</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 将中文文件名称修改为拼音首字母、拼音全称）</title>
    <url>/blog/2020/02/11/Java-%E5%B0%86%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0%E4%BF%AE%E6%94%B9%E4%B8%BA%E6%8B%BC%E9%9F%B3%E9%A6%96%E5%AD%97%E6%AF%8D%E3%80%81%E6%8B%BC%E9%9F%B3%E5%85%A8%E7%A7%B0/</url>
    <content><![CDATA[<p>在日常工作中，由于一些软件导入文件时对中文不支持，需要修改文件名称为拼音或者拼音首字母，修改方式也多种多样，本文通过Java来进行修改。</p>
<a id="more"></a>

<blockquote>
<p>正文</p>
</blockquote>
<p>在日常工作中，由于一些软件导入文件时对中文不支持，需要修改文件名称为拼音或者拼音首字母，修改方式也多种多样，本文通过Java来进行修改。</p>
<ul>
<li><h3 id="引入Maven依赖"><a href="#引入Maven依赖" class="headerlink" title="引入Maven依赖"></a>引入Maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.belerweb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pinyin4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="中文转拼音"><a href="#中文转拼音" class="headerlink" title="中文转拼音"></a>中文转拼音</h3><p>主要通过pinyin4j进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取汉字串拼音首字母，英文字符不变</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chinese</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFirstSpell</span><span class="params">(String chinese)</span> </span>&#123;</span><br><span class="line">        StringBuffer pybf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">char</span>[] arr = chinese.toCharArray();</span><br><span class="line">        HanyuPinyinOutputFormat defaultFormat = <span class="keyword">new</span> HanyuPinyinOutputFormat();</span><br><span class="line">        defaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);</span><br><span class="line">        defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; <span class="number">128</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String[] temp = PinyinHelper.toHanyuPinyinStringArray(arr[i], defaultFormat);</span><br><span class="line">                    <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        pybf.append(temp[<span class="number">0</span>].charAt(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BadHanyuPinyinOutputFormatCombination e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pybf.append(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pybf.toString().replaceAll(<span class="string">"\\W"</span>, <span class="string">""</span>).trim().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取汉字串拼音，英文字符不变</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chinese</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFullSpell</span><span class="params">(String chinese)</span> </span>&#123;</span><br><span class="line">        StringBuffer pybf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">char</span>[] arr = chinese.toCharArray();</span><br><span class="line">        HanyuPinyinOutputFormat defaultFormat = <span class="keyword">new</span> HanyuPinyinOutputFormat();</span><br><span class="line">        defaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);</span><br><span class="line">        defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; <span class="number">128</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pybf.append(PinyinHelper.toHanyuPinyinStringArray(arr[i], defaultFormat)[<span class="number">0</span>]);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BadHanyuPinyinOutputFormatCombination e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pybf.append(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pybf.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="批量修改"><a href="#批量修改" class="headerlink" title="批量修改"></a>批量修改</h3><p>使用<strong>Hutool</strong>的<code>IOUtil、FileUtil</code>工具类对文件进行复制。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、待转换文件所在文件夹</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"E:\\needConvert\\"</span>);</span><br><span class="line">        <span class="comment">//2、转换之后文件生成的文件夹位置</span></span><br><span class="line">        File filecopy = <span class="keyword">new</span> File(<span class="string">"E:\\converted\\"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!filecopy.exists()) &#123;</span><br><span class="line">            filecopy.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BufferedInputStream in = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        File[] filelist = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File fi : filelist) &#123;</span><br><span class="line">            <span class="comment">//1、获取到文件名</span></span><br><span class="line">            String substring = fi.getName().substring(<span class="number">0</span>, fi.getName().indexOf(<span class="string">'.'</span>));</span><br><span class="line">            <span class="comment">//2、文件名中文转换为拼音首字母</span></span><br><span class="line">            String newPrefix = getFirstSpell(substring);</span><br><span class="line">            <span class="comment">//3、获取文件的后缀</span></span><br><span class="line">            String suffix = fi.getName().substring(fi.getName().lastIndexOf(<span class="string">'.'</span>));</span><br><span class="line">            <span class="comment">//4、将需要处理的文件输入到流中</span></span><br><span class="line">            in = FileUtil.getInputStream(fi);</span><br><span class="line">            <span class="comment">//5、新文件的名称及地址：filecopy + newPrefix + suffix</span></span><br><span class="line">            String newFilePath = filecopy + File.separator + newPrefix + suffix;</span><br><span class="line"></span><br><span class="line">            File newfile = <span class="keyword">new</span> File(newFilePath);</span><br><span class="line">            <span class="keyword">if</span> (!newfile.exists()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    newfile.createNewFile();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            out = FileUtil.getOutputStream(newFilePath);</span><br><span class="line">            <span class="comment">//6、使用Hutool进行复制</span></span><br><span class="line">            <span class="keyword">long</span> copyTime = IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE);</span><br><span class="line">            System.out.printf(<span class="string">"转换耗时: %d \n"</span>, copyTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码地址： <a href="https://github.com/copyers/JavaUtils" target="_blank" rel="noopener">https://github.com/copyers/JavaUtils</a>.<br>以上就是通过Java来转换中文的过程，不过个人觉得批量修改文件名可以通过脚本来遍历修改，更加方便快捷。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MAVEN</tag>
      </tags>
  </entry>
  <entry>
    <title>都2020年了你还在闭门造车吗？快来看看这篇面向B站学习Java之最新最全推荐（长期更新）</title>
    <url>/blog/2020/02/11/%E9%83%BD2020%E5%B9%B4%E4%BA%86%E4%BD%A0%E8%BF%98%E5%9C%A8%E9%97%AD%E9%97%A8%E9%80%A0%E8%BD%A6%E5%90%97%EF%BC%9F%E5%BF%AB%E6%9D%A5%E7%9C%8B%E7%9C%8B%E8%BF%99%E7%AF%87%E9%9D%A2%E5%90%91B%E7%AB%99%E5%AD%A6%E4%B9%A0Java%E4%B9%8B%E6%9C%80%E6%96%B0%E6%9C%80%E5%85%A8%E6%8E%A8%E8%8D%90%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<img src="https://img-blog.csdnimg.cn/20200130212950684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1l1ZVlpbmdHdWFuZw==,size_16,color_FFFFFF,t_70" alt="" style="width:100%" />
<a id="more"></a>

<h3 id="新型冠状病毒的肆虐，提醒大家少出门、戴口罩、勤洗手，武汉加油，中国加油！！！"><a href="#新型冠状病毒的肆虐，提醒大家少出门、戴口罩、勤洗手，武汉加油，中国加油！！！" class="headerlink" title="新型冠状病毒的肆虐，提醒大家少出门、戴口罩、勤洗手，武汉加油，中国加油！！！"></a>新型冠状病毒的肆虐，提醒大家少出门、戴口罩、勤洗手，武汉加油，中国加油！！！</h3><p>趁着这段时间回顾了2019年自己的学习情况，2019年其实主要是通过B站观看视频教程进行学习，个人几乎把以下推荐的全部视频都抽时间看了一遍以上，筛选了以下教程推荐给想要学习Java的同学，该教程涵盖了<strong>Java从入门</strong>、<strong>进阶以及到高级</strong>的全部知识，适合现在想要学习Java的所有同学，同时也非常感谢互联网，感谢小破站，感谢各大慷慨的教育机构，感谢韩顺平老师，感谢周阳老师，感谢雷丰阳老师等等，正是他们的无私让现在学习变得越来越简单。</p>
<blockquote>
<p>以下分享的视频教程99%来源于B站（哔哩哔哩）其余来自于慕课网，目前还有中间件及Java面试部分未整理，以后如果发现好的视频教程也会不定期更新。</p>
</blockquote>
<h3 id="正-文"><a href="#正-文" class="headerlink" title="正 文"></a>正 文</h3><h4 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a>一、Java基础</h4><p>1、尚硅谷宋红康（强力推荐）：<a href="https://www.bilibili.com/video/av48144058" target="_blank" rel="noopener">https://www.bilibili.com/video/av48144058</a></p>
<p>2、黑马Java基础+就业班+各种项目idea版本（推荐）：<a href="https://www.bilibili.com/video/av55246614" target="_blank" rel="noopener">https://www.bilibili.com/video/av55246614</a></p>
<p>3、动力节点Java零基础教程视频： <a href="https://www.bilibili.com/video/av11361088" target="_blank" rel="noopener">https://www.bilibili.com/video/av11361088</a></p>
<p>4、北京尚学堂高琪（推荐）：<a href="https://www.bilibili.com/video/av30023103" target="_blank" rel="noopener">https://www.bilibili.com/video/av30023103</a></p>
<p>5、求知讲堂：2019求知讲堂零基础Java入门编程视频教程 高口碑 无废话 无尿点 ： <a href="https://www.bilibili.com/video/av76235341" target="_blank" rel="noopener">https://www.bilibili.com/video/av76235341</a></p>
<h4 id="二、数据结构与算法"><a href="#二、数据结构与算法" class="headerlink" title="二、数据结构与算法"></a>二、数据结构与算法</h4><p>1、郝斌-数据结构入门：<a href="https://www.bilibili.com/video/av6159200" target="_blank" rel="noopener">https://www.bilibili.com/video/av6159200</a></p>
<p>2、尚硅谷韩顺平图解Java数据结构与算法: <a href="https://www.bilibili.com/video/av54029771" target="_blank" rel="noopener">https://www.bilibili.com/video/av54029771</a></p>
<h4 id="三、图解Java设计模式"><a href="#三、图解Java设计模式" class="headerlink" title="三、图解Java设计模式"></a>三、图解Java设计模式</h4><p>1、尚硅谷韩顺平：<a href="https://www.bilibili.com/video/av57936239" target="_blank" rel="noopener">https://www.bilibili.com/video/av57936239</a></p>
<h4 id="四、Java源码"><a href="#四、Java源码" class="headerlink" title="四、Java源码"></a>四、Java源码</h4><p>1 、Java 源码分析：<a href="https://www.bilibili.com/video/av74161334" target="_blank" rel="noopener">https://www.bilibili.com/video/av74161334</a></p>
<p>2、HashMap源码解读：<a href="https://www.bilibili.com/video/av75133052" target="_blank" rel="noopener">https://www.bilibili.com/video/av75133052</a></p>
<h4 id="五、Java框架整合"><a href="#五、Java框架整合" class="headerlink" title="五、Java框架整合"></a>五、Java框架整合</h4><p>1、尚硅谷Java视频教程_SSM整合视频教程：<a href="https://www.bilibili.com/video/av21045215" target="_blank" rel="noopener">https://www.bilibili.com/video/av21045215</a></p>
<p>2、尚硅谷雷丰阳大神的Spring、Spring MVC、MyBatis课程：<a href="https://www.bilibili.com/video/av56193747" target="_blank" rel="noopener">https://www.bilibili.com/video/av56193747</a></p>
<p>3、黑马SSM教程：<a href="https://www.bilibili.com/video/av47952553" target="_blank" rel="noopener">https://www.bilibili.com/video/av47952553</a></p>
<p>4、SSM框架视频整合+(传智播客)：<a href="https://www.bilibili.com/video/av29422149" target="_blank" rel="noopener">https://www.bilibili.com/video/av29422149</a></p>
<p>5、SSM框架整合教学IDEA版最新：<a href="https://www.bilibili.com/video/av73118229" target="_blank" rel="noopener">https://www.bilibili.com/video/av73118229</a></p>
<h4 id="六、Spring源码"><a href="#六、Spring源码" class="headerlink" title="六、Spring源码"></a>六、Spring源码</h4><p>1、spring源码全集：<a href="https://www.bilibili.com/video/av71093907" target="_blank" rel="noopener">https://www.bilibili.com/video/av71093907</a></p>
<p>2、Spring4.x入门视频教程_王泽(广陵散)：<a href="https://www.bilibili.com/video/av40323796" target="_blank" rel="noopener">https://www.bilibili.com/video/av40323796</a></p>
<p>3、spring-spring注解驱动开发-源码版-雷丰阳-尚硅谷：<a href="https://www.bilibili.com/video/av71252572" target="_blank" rel="noopener">https://www.bilibili.com/video/av71252572</a></p>
<p>4、Spring5最新完整教程IDEA版【通俗易懂】：<a href="https://www.bilibili.com/video/av71110355" target="_blank" rel="noopener">https://www.bilibili.com/video/av71110355</a></p>
<h4 id="七、SpringMVC"><a href="#七、SpringMVC" class="headerlink" title="七、SpringMVC"></a>七、SpringMVC</h4><p>1、尚硅谷佟刚Java视频教程_SpringMVC视频：<a href="https://www.bilibili.com/video/av21272240" target="_blank" rel="noopener">https://www.bilibili.com/video/av21272240</a></p>
<p>2、SpringMVC最新教程IDEA版：<a href="https://www.bilibili.com/video/av71874024" target="_blank" rel="noopener">https://www.bilibili.com/video/av71874024</a></p>
<p>3、黑马程序员SpringMVC：<a href="https://www.bilibili.com/video/av18288362" target="_blank" rel="noopener">https://www.bilibili.com/video/av18288362</a></p>
<p>4、千锋Java：SpringMVC框架教程：<a href="https://www.bilibili.com/video/av45556876" target="_blank" rel="noopener">https://www.bilibili.com/video/av45556876</a></p>
<h4 id="八、Mybatis、MyBatisPlus"><a href="#八、Mybatis、MyBatisPlus" class="headerlink" title="八、Mybatis、MyBatisPlus"></a>八、Mybatis、MyBatisPlus</h4><p>1、尚硅谷Java视频教程_MyBatis视频教程（源码级讲授的MyBatis视频）：<a href="https://www.bilibili.com/video/av21272940" target="_blank" rel="noopener">https://www.bilibili.com/video/av21272940</a></p>
<p>2、尚硅谷MyBatisPlus教程：<a href="https://www.bilibili.com/video/av27212529" target="_blank" rel="noopener">https://www.bilibili.com/video/av27212529</a></p>
<p>3、Mybatis最新完整教程IDEA版【通俗易懂】：<a href="https://www.bilibili.com/video/av69742084" target="_blank" rel="noopener">https://www.bilibili.com/video/av69742084</a></p>
<p>4、MyBatis-Plus入门：<a href="https://www.imooc.com/learn/1130" target="_blank" rel="noopener">https://www.imooc.com/learn/1130</a></p>
<p>5、MyBatis-Plus进阶：<a href="https://www.imooc.com/learn/1171" target="_blank" rel="noopener">https://www.imooc.com/learn/1171</a></p>
<h4 id="九、SpringBoot（部分还在更新中）"><a href="#九、SpringBoot（部分还在更新中）" class="headerlink" title="九、SpringBoot（部分还在更新中）"></a>九、SpringBoot（部分还在更新中）</h4><p>1、尚硅谷SpringBoot整合篇：<a href="https://www.bilibili.com/video/av23284778" target="_blank" rel="noopener">https://www.bilibili.com/video/av23284778</a></p>
<p>2、SpringBoot最新教程IDEA版：<a href="https://www.bilibili.com/video/av75233634" target="_blank" rel="noopener">https://www.bilibili.com/video/av75233634</a></p>
<p>3、2020年最新springboot2.0+shiro+jwt+redis+swagger+layui+thymeleaf 前后端：<a href="https://www.bilibili.com/video/av78917587" target="_blank" rel="noopener">https://www.bilibili.com/video/av78917587</a></p>
<p>4、尚硅谷好评如潮【SpringBoot】视频：<a href="https://www.bilibili.com/video/av20965295" target="_blank" rel="noopener">https://www.bilibili.com/video/av20965295</a></p>
<p>5、SpringBoot项目实战 视频教程全集 | 35小时：<a href="https://www.bilibili.com/video/av62800055" target="_blank" rel="noopener">https://www.bilibili.com/video/av62800055</a></p>
<p>6、SpringBoot项目实战：企业项目管理系统：<a href="https://www.bilibili.com/video/av65870246" target="_blank" rel="noopener">https://www.bilibili.com/video/av65870246</a></p>
<h4 id="十、SpringCloud（部分还在更新中）"><a href="#十、SpringCloud（部分还在更新中）" class="headerlink" title="十、SpringCloud（部分还在更新中）"></a>十、SpringCloud（部分还在更新中）</h4><p>1、SpringCloud-尚硅谷：<a href="https://www.bilibili.com/video/av49106064" target="_blank" rel="noopener">https://www.bilibili.com/video/av49106064</a></p>
<p>2、2018千锋Java高级教程-Java微服务架构：<a href="https://www.bilibili.com/video/av36042649" target="_blank" rel="noopener">https://www.bilibili.com/video/av36042649</a></p>
<p>3、SpringCloud最新教程IDEA版：<a href="https://www.bilibili.com/video/av76020761" target="_blank" rel="noopener">https://www.bilibili.com/video/av76020761</a></p>
<p>4、SpringCloud+Vue项目实战——社交项目：<a href="https://www.bilibili.com/video/av63499215" target="_blank" rel="noopener">https://www.bilibili.com/video/av63499215</a></p>
<h4 id="十一、JVM"><a href="#十一、JVM" class="headerlink" title="十一、JVM"></a>十一、JVM</h4><p>1、juc 与 jvm - Java 必学 2019版本-阳哥- 尚硅谷- idea：<a href="https://www.bilibili.com/video/av70166821" target="_blank" rel="noopener">https://www.bilibili.com/video/av70166821</a></p>
<p>2、尚硅谷_JVM从入门到精通宋红康2020版（持续更新中）：<a href="https://www.bilibili.com/video/av83622425" target="_blank" rel="noopener">https://www.bilibili.com/video/av83622425</a></p>
<p>3、深入理解JVM-张龙：<a href="https://www.bilibili.com/video/av78983356" target="_blank" rel="noopener">https://www.bilibili.com/video/av78983356</a></p>
<h4 id="十二、MySQL"><a href="#十二、MySQL" class="headerlink" title="十二、MySQL"></a>十二、MySQL</h4><p>1、尚硅谷周阳（强力推荐）：<a href="https://www.bilibili.com/video/av21334868" target="_blank" rel="noopener">https://www.bilibili.com/video/av21334868</a></p>
<p>2、MySQL 基础+高级篇- 数据库 -sql -尚硅谷：<a href="https://www.bilibili.com/video/av49181542" target="_blank" rel="noopener">https://www.bilibili.com/video/av49181542</a></p>
<h4 id="十三、Linux"><a href="#十三、Linux" class="headerlink" title="十三、Linux"></a>十三、Linux</h4><p>1、尚硅谷_韩顺平_Linux教程：<a href="https://www.bilibili.com/video/av21303002" target="_blank" rel="noopener">https://www.bilibili.com/video/av21303002</a></p>
<h4 id="十四、工具篇"><a href="#十四、工具篇" class="headerlink" title="十四、工具篇"></a>十四、工具篇</h4><p><strong>MAVEN</strong></p>
<p>1、尚硅谷Java视频教程_Maven视频: <a href="https://www.bilibili.com/video/av36557763" target="_blank" rel="noopener">https://www.bilibili.com/video/av36557763</a></p>
<p>2、Maven基础篇：<a href="https://www.bilibili.com/video/av54119831" target="_blank" rel="noopener">https://www.bilibili.com/video/av54119831</a></p>
<p><strong>IDEA</strong></p>
<p>1、尚硅谷Java视频教程_IDEA视频教程：<a href="https://www.bilibili.com/video/av30080993" target="_blank" rel="noopener">https://www.bilibili.com/video/av30080993</a></p>
<p>2、IDEA教程-干货大合集：<a href="https://www.bilibili.com/video/av34324988" target="_blank" rel="noopener">https://www.bilibili.com/video/av34324988</a></p>
<p>3、idea超详细使用教程：<a href="https://www.bilibili.com/video/av67438327" target="_blank" rel="noopener">https://www.bilibili.com/video/av67438327</a></p>
<p><strong>Git</strong></p>
<p>1、学会Git玩转Github： <a href="https://www.bilibili.com/video/av10475153" target="_blank" rel="noopener">https://www.bilibili.com/video/av10475153</a></p>
<p>2、尚硅谷_Git&amp;GitHub：<a href="https://www.bilibili.com/video/av24441039" target="_blank" rel="noopener">https://www.bilibili.com/video/av24441039</a></p>
<p>3、1小时玩转 Git/Github：<a href="https://www.bilibili.com/video/av55780016" target="_blank" rel="noopener">https://www.bilibili.com/video/av55780016</a></p>
<blockquote>
<p>相信看完以上教程，吸收完其中的知识点，那么你会对Java有一个更深刻的认识，不过就像韩顺平老师说的那样，“纸上得来终觉浅，绝知此事要躬行”，应用型的知识技能一定要经常使用，经常练才能理解，才能掌握，所以一定要将所学到的知识应用到实际项目中，这样才能通过解决问题来获得更快的成长。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
        <tag>SpringBoot</tag>
        <tag>Git</tag>
        <tag>IDEA</tag>
        <tag>JVM</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官：写几种你知道的单例模式！Java实现单例模式有几种方式？3，5？饿汉，懒汉！？</title>
    <url>/blog/2020/02/11/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%86%99%E5%87%A0%E7%A7%8D%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%81Java%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F3%EF%BC%8C5%EF%BC%9F%E9%A5%BF%E6%B1%89%EF%BC%8C%E6%87%92%E6%B1%89%EF%BC%81%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>在面试中经常会遇到单例模式的问题，动不动就是你知道几种单例模式，请手写几种你知道的单例模式，为了能彻底厘清该问题，本文详细阐述了单例模式的最全的八种写法以及茴香豆的茴字的四种写法（手动狗头），并比较其存在的优劣，如果本文对你有所帮助的话点赞哦亲。</p>
</blockquote>
<a id="more"></a>
<ul>
<li><h4 id="什么是设计模式（Design-Pattern）？"><a href="#什么是设计模式（Design-Pattern）？" class="headerlink" title="什么是设计模式（Design Pattern）？"></a>什么是设计模式（Design Pattern）？</h4><p>设计模式是人类在解决各类问题时所总结出来的有用的经验，它不是软件工程中特有的概念。具体来说<strong>设计模式是一种思想</strong>，是解决某类问题的通用方案，代表了最佳实践，也是前人经过相当长时间的试验和错误而分析总结出来的。</p>
</li>
<li><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>设计模式总共分为三类，总共<strong>23</strong>种</p>
<ul>
<li><strong>创建型</strong> ：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</li>
<li><strong>结构型</strong> ：适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式、代理模式</li>
<li><strong>行为型</strong> ： 模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）</li>
</ul>
</li>
</ul>
<blockquote>
<p><font size = 6>正文开始</font></p>
</blockquote>
<ul>
<li><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p><strong>单例模式就是通过某种实现方式使得在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得该对象实例的静态方法。</strong></p>
<blockquote>
<p>应用场景：</p>
<p>​        1、比如Windows的资源管理器，同一台Windows上不能同时打开两个资源管理器。</p>
<p>​        2、数据库连接池，因为数据库连接是一种数据库资源，为了节省打开或者关闭数据库连接所引起的损耗，单例模式的使用就尤为重要。</p>
<p>​        3、Spring对bean的管理，可以通过scope选择该bean是单例（singleton）还是多例（prototype）。</p>
</blockquote>
<p>综上所述，单例模式在软件工程中使用还是比较频繁的，为了能在面试中能够脱颖而出让面试官中意你，并且工作中遇到能熟练运用，下面主要通过代码的方式来详细介绍单例模式的八种实现方式。</p>
<p><strong>单例模式的八种实现方式</strong></p>
<blockquote>
<ol>
<li><strong>饿汉式（静态常量）</strong></li>
<li>饿汉式（静态代码块）</li>
<li>懒汉式（线程不安全）</li>
<li>懒汉式（线程安全，同步方法实现）</li>
<li>懒汉式（线程安全，同步代码块实现）</li>
<li><strong>双重检查（Double Check）</strong></li>
<li><strong>静态内部类</strong></li>
<li><strong>枚举</strong></li>
</ol>
</blockquote>
</li>
<li><h4 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h4></li>
</ul>
<h4 id="1-饿汉式（静态常量）"><a href="#1-饿汉式（静态常量）" class="headerlink" title="1. 饿汉式（静态常量）"></a>1. 饿汉式（静态常量）</h4><p>  ​    步骤：</p>
<p>  ​    ①、私有化构造器,防止外部通过<code>new</code>生成实例</p>
<p>  ​    ②、提供一个同类型的常量,用于接收内部实例</p>
<p>  ​    ③、提供一个<code>public</code>方法供外部调用以获取生成的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、私有化构造器,防止外部new产生实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、定义一个Singleton类型的常量,用于接收Singleton内部实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、定义一个public方法提供给外部调用，获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>优点：</strong></p>
<blockquote>
<p>实现较为简单，定义为常量即在类加载的时候就完成实例化。通过<code>ClassLoader</code>机制避免了线程安全的问题。</p>
</blockquote>
</li>
<li><p><strong>缺点：</strong></p>
<blockquote>
<p>根据<code>JVM</code>加载类的方式得知类加载器并不需要等到某个类被主动使用时才加载，<code>JVM</code>允许类加载器在预料到某个类将要被使用时就预先加载它，所以类加载是一种<font color=#ff0000><strong>不确定行为</strong></font>，而这种饿汉式的实现方式会在类加载的时候就完成实例化，所以不能达到懒加载（<code>Lazy Loading</code>）的效果。<font color=#ff0000><strong>可能造成内存浪费。</strong></font></p>
</blockquote>
</li>
</ul>
<h4 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2. 饿汉式（静态代码块）"></a>2. 饿汉式（静态代码块）</h4><p>  ​    步骤：</p>
<p>  ​    ①、私有化构造器,防止外部通过<code>new</code>生成实例</p>
<p>  ​    ②、定义<code>static</code>实例对象,用于接收静态代码块生成的内部实例</p>
<p>  ​    ③、通过静态代码块创建对象实例</p>
<p>  ​    ④、提供一个<code>public</code>方法供外部调用以获取生成的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、私有化构造器,防止外部new产生实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、定义实例对象准备接收</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、通过静态代码块创建对象实例</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、定义一个public方法提供给外部调用，获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>该方法优缺点同上（<font color=#ff0000>可能造成内存浪费</font>）</strong></li>
</ul>
<h4 id="3-懒汉式（线程不安全）"><a href="#3-懒汉式（线程不安全）" class="headerlink" title="3. 懒汉式（线程不安全）"></a>3. 懒汉式（线程不安全）</h4><p>​        步骤：</p>
<p>​        ①、私有化构造器,防止外部通过<code>new</code>生成实例</p>
<p>​        ②、定义<code>static</code>实例对象,用于接收静态代码块生成的内部实例</p>
<p>​        ③、提供一个<code>public</code>方法供外部调用以获取生成的实例，首先判断该实例是否已经生成，如果已经生成则直接使用，否则再实例化生成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、私有化构造器,防止外部new产生实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、定义一个static实例对象接收对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、定义一个public方法提供给外部调用，获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>优点：</strong></p>
<blockquote>
<p>实现简单且可以实现懒加载（Lazy Loading）</p>
</blockquote>
</li>
<li><p><strong>缺点：</strong></p>
<blockquote>
<p>if(null == instance)该句代码在多线程环境存在线程不安全问题，可能生成多个实例，破坏了单例模式。<font color=#ff0000><strong>实际开发中不要使用这种方式。</strong></font></p>
</blockquote>
</li>
</ul>
<h4 id="4-懒汉式（线程安全，同步方法实现）"><a href="#4-懒汉式（线程安全，同步方法实现）" class="headerlink" title="4. 懒汉式（线程安全，同步方法实现）"></a>4. 懒汉式（线程安全，同步方法实现）</h4><p>​    步骤：</p>
<p>​    ①、私有化构造器,防止外部通过<code>new</code>生成实例</p>
<p>​    ②、定义<code>static</code>实例对象,用于接收静态代码块生成的内部实例</p>
<p>​    ③、提供一个<code>public</code>方法供外部调用以获取生成的实例并通过<code>synchronized</code>加锁，首先判断该实例是否已经生成，如果已经生成则直接使用，否则再实例化生成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、私有化构造器,防止外部new产生实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、定义一个static实例对象接收对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、定义一个public方法提供给外部调用，通过synchronized加锁，获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>优点：</strong></p>
<blockquote>
<p>解决了懒汉式了线程安全的问题。</p>
</blockquote>
</li>
<li><p><strong>缺点：</strong></p>
<blockquote>
<p>由于通过synchronized加锁，多线程环境下获取对象实例效率极低。<font color=#ff0000><strong>实际开发不推荐使用。</strong></font></p>
</blockquote>
</li>
</ul>
<h4 id="5-懒汉式（线程安全，同步代码块实现）"><a href="#5-懒汉式（线程安全，同步代码块实现）" class="headerlink" title="5. 懒汉式（线程安全，同步代码块实现）"></a>5. 懒汉式（线程安全，同步代码块实现）</h4><p>​    步骤：</p>
<p>​    ①、私有化构造器,防止外部通过<code>new</code>生成实例</p>
<p>​    ②、定义<code>static</code>实例对象,用于接收静态代码块生成的内部实例</p>
<p>​    ③、提供一个<code>public</code>方法供外部调用以获取生成的实例并通过<code>synchronized</code>加锁，首先判断该实例是否已经生成，如果已经生成则直接使用，否则再实例化生成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、私有化构造器,防止外部new产生实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、定义一个static实例对象接收对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、定义一个public方法提供给外部调用，通过synchronized同步代码块加锁，获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">         		instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>缺点：</strong></p>
<blockquote>
<p>通过synchronized代码块加锁，依然线程不安全。<font color=#ff0000><strong>实际开发不推荐使用。</strong></font></p>
</blockquote>
</li>
</ul>
<h4 id="6-双重检查"><a href="#6-双重检查" class="headerlink" title="6. 双重检查"></a>6. 双重检查</h4><p>步骤：</p>
<p>​    ①、私有化构造器,防止外部通过<code>new</code>生成实例</p>
<p>​    ②、定义<code>volatile</code>实例对象,保证生成实例对象的可见性,并用于接收静态代码块生成的内部实例</p>
<p>​    ③、定义一个public方法提供给外部调用，获取实例对象，同时再在内部进行两次判断，第二次进行synchronized代码块加锁，一旦实例化成功，锁外的线程即可通过<code>volatile</code>获得实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1、私有化构造器,防止外部new产生实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、定义volatile实例对象,保证数据可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、定义一个public方法提供给外部调用，获取实例对象，同时再在内部进行进行synchronized代码块加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>优点：</strong></p>
<blockquote>
<p>实现了懒加载（<code>Lazy Loading</code>）</p>
<p>双重检查，保证线程安全</p>
<p>实例化代码只用执行一次，多线程后面再次访问时可通过<code>volatile</code>通知。</p>
</blockquote>
</li>
</ul>
<p><font color=#ff0000><strong>推荐使用。</strong></font></p>
<h4 id="7-静态内部类"><a href="#7-静态内部类" class="headerlink" title="7. 静态内部类"></a>7. 静态内部类</h4><p>​    步骤：</p>
<p>​    ①、私有化构造器,防止外部通过<code>new</code>生成实例</p>
<p>​    ②、通过静态内部类的属性获得<code>Singleton</code>实例</p>
<p>​    ③、定义一个<code>public</code>方法提供给外部调用，获取实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、私有化构造器,防止外部new产生实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、通过静态内部类的属性获得Singleton实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、定义一个public方法提供给外部调用，获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>优点：</strong></p>
<blockquote>
<p>实现了懒加载（<code>Lazy Loading</code>）</p>
<p>只有当<code>getInstance()</code>方法第一次被调用时，才会去导致虚拟机加载<code>SingletonInstance</code>类，而类的静态属性只会在第一次加载类的时候初始化，所以这种方式通过<code>JVM</code>的加载机制以保证线程安全。</p>
</blockquote>
</li>
</ul>
<p><font color=#ff0000><strong>推荐使用。</strong></font></p>
<h4 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8. 枚举"></a>8. 枚举</h4><p>​    步骤：</p>
<p>​    ①、通过枚举类属性实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>优点：</strong></p>
<blockquote>
<p>线程安全，实现简单</p>
<p>防止反序列化重新创建新的对象</p>
</blockquote>
</li>
</ul>
<p><font color=#ff0000><strong>强烈推荐使用。</strong></font></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以极大地提高系统性能，例如数据库连接池，<code>session</code>工厂等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
</search>
